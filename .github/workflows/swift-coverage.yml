name: Swift Test Coverage

on:
  workflow_call:
    inputs:
      # Basic configuration
      macos-version:
        description: 'macOS runner version (e.g., "latest", "15", "14")'
        required: false
        type: string
        default: 'latest'
      xcode-version:
        description: 'Xcode version to use (default: system default)'
        required: false
        type: string
        default: ''
      platforms-override:
        description: 'Override platforms to test (reusable workflow supports macOS only)'
        required: false
        type: string
        default: 'macos'
      source-path-override:
        description: 'Override source path pattern (default: {PROJECT}/Sources)'
        required: false
        type: string
      project-name-override:
        description: 'Override project name (default: repository name)'
        required: false
        type: string
      coverage-comment-header:
        description: 'Header for coverage comment'
        required: false
        type: string
        default: '### üõ°Ô∏è Code Coverage Report'
      working-directory:
        description: 'Working directory for Swift commands (default: repository root)'
        required: false
        type: string
        default: '.'
      skip-label:
        description: 'Label name to skip workflow execution (default: skip-coverage)'
        required: false
        type: string
        default: 'skip-coverage'

      # Multi-job combined comments
      post-comment:
        description: 'Post coverage comment to PR (set to false when using combined comments)'
        required: false
        type: boolean
        default: true
      job-name:
        description: 'Name/description for this coverage job (used in combined reports)'
        required: false
        type: string
        default: ''

      # Coverage threshold
      coverage-threshold:
        description: 'Coverage threshold percentage (if set, enables quality indicators and Details section)'
        required: false
        type: string
        default: ''
      fail-on-low-coverage:
        description: 'Fail the job if coverage is below threshold'
        required: false
        type: boolean
        default: false

    outputs:
      coverage-percentage:
        description: 'The calculated coverage percentage'
        value: ${{ jobs.coverage.outputs.coverage }}

      # Multi-job combined comments
      coverage-table:
        description: 'The coverage table in markdown format'
        value: ${{ jobs.coverage.outputs.coverage-table }}
      job-name:
        description: 'The job name for this coverage run'
        value: ${{ inputs.job-name }}

env:
  XCODE_PATH: '/Applications/Xcode_${{ inputs.xcode-version }}.app/Contents/Developer'
  COVERAGE_SUMMARY_FILE: '${{ github.workspace }}/coverage_summary.txt'

jobs:
  coverage:
    if: ${{ !contains(github.event.pull_request.labels.*.name, inputs.skip-label) }}
    runs-on: macos-${{ inputs.macos-version }}
    outputs:
      coverage: ${{ steps.extract.outputs.coverage }}
      coverage-table: ${{ steps.extract.outputs.coverage-table }}
    defaults:
      run:
        working-directory: ${{ inputs.working-directory }}

    steps:
    - uses: actions/checkout@v4

    - name: List Xcode installations
      run: sudo ls -1 /Applications | grep "Xcode" || echo "No Xcode installations found"

    - name: Validate Xcode version
      if: inputs.xcode-version != ''
      run: |
        REQUESTED_XCODE="Xcode_${{ inputs.xcode-version }}.app"
        if [ ! -d "/Applications/$REQUESTED_XCODE" ]; then
          echo "‚ùå Error: Xcode version ${{ inputs.xcode-version }} is not installed"
          echo ""
          echo "Available Xcode versions:"
          sudo ls -1 /Applications | grep "Xcode" | sed 's/Xcode_//g' | sed 's/.app//g' | sed 's/^/  - /'
          echo ""
          echo "Please update your workflow to use one of the available versions."
          exit 1
        fi
        echo "‚úÖ Xcode ${{ inputs.xcode-version }} is available"

    - name: Select Xcode ${{ inputs.xcode-version }}
      if: inputs.xcode-version != ''
      run: sudo xcode-select -s ${{ env.XCODE_PATH }}

    - name: Verify Swift Version
      run: swift --version

    - name: Run Swift Tests with Coverage
      run: |
        swift test --enable-swift-testing --enable-code-coverage

        PROJECT_NAME="${{ inputs.project-name-override }}"
        [ -z "$PROJECT_NAME" ] && PROJECT_NAME="${{ github.event.repository.name }}"

        PACKAGE_NAME=$(swift package dump-package 2>/dev/null | jq -r '.name' 2>/dev/null || echo "$PROJECT_NAME")
        CODECOV_PATH=".build/debug/codecov/${PACKAGE_NAME}.json"
        [ ! -f "$CODECOV_PATH" ] && CODECOV_PATH=$(find .build/debug/codecov -name "*.json" -type f | head -1)

        echo "CODECOV_PATH=$CODECOV_PATH" >> $GITHUB_ENV

    - name: Process Coverage Data
      id: extract
      run: |
        PROJECT_NAME="${{ inputs.project-name-override }}"
        [ -z "$PROJECT_NAME" ] && PROJECT_NAME="${{ github.event.repository.name }}"

        if [ ! -f "$CODECOV_PATH" ]; then
          echo "‚ùå Error: Coverage file not found at $CODECOV_PATH"
          exit 1
        fi

        echo "Processing coverage from: $CODECOV_PATH"

        set +e
        SOURCE_FILES=$(jq -r '.data[0].files[] | select(.filename | test("/\\.build/") | not) | select(.filename | test("\\.swift$")) | select(.filename | test("/(Tests?|test)/") | not) | .filename' "$CODECOV_PATH" 2>&1)
        jq_exit_code=$?
        set -e

        if [ $jq_exit_code -ne 0 ]; then
          echo "‚ùå Error: Failed to parse coverage JSON (exit code: $jq_exit_code)"
          echo "jq output: $SOURCE_FILES"
          echo ""
          echo "Coverage file content (first 30 lines):"
          head -30 "$CODECOV_PATH"
          exit 1
        fi

        SOURCE_FILE_COUNT=$(echo "$SOURCE_FILES" | grep -c . || echo "0")

        if [ "$SOURCE_FILE_COUNT" -eq 0 ]; then
          ALL_FILES="$PROJECT_NAME|0|0"
        else
          set +e
          ALL_FILES=$(jq -r '.data[0].files[] | select(.filename | test("/\\.build/") | not) | select(.filename | test("\\.swift$")) | select(.filename | test("/(Tests?|test)/") | not) | "\(.filename)|\(.summary.lines.count)|\(.summary.lines.covered)"' "$CODECOV_PATH" 2>&1)
          jq_exit_code=$?
          set -e

          if [ $jq_exit_code -ne 0 ]; then
            echo "‚ùå Error: Failed to extract coverage data (exit code: $jq_exit_code)"
            echo "jq output: $ALL_FILES"
            exit 1
          fi
        fi

        THRESHOLD="${{ inputs.coverage-threshold }}"
        [ -n "$THRESHOLD" ] && show_quality="true" || show_quality="false"

        TARGETS_DATA=$(mktemp)
        TABLE_BODY=$(mktemp)
        COVERAGE_VALUES=$(mktemp)

        while IFS='|' read -r filename total_lines covered_lines; do
          if [ -n "$filename" ]; then
            target_name=""

            if echo "$filename" | grep -q '/Sources/[^/]*/'; then
              target_name=$(echo "$filename" | sed -E 's|.*/Sources/([^/]+)/.*|\1|')
            elif echo "$filename" | grep -q '/Sources/[^/]*\.swift$'; then
              target_name=$(echo "$filename" | sed -E 's|.*/Sources/([^/]*)\.swift$|\1|')
            else
              target_name="$PROJECT_NAME"
            fi

            echo "$target_name" | grep -qi test && continue
            echo "$target_name|$total_lines|$covered_lines" >> "$TARGETS_DATA"
          fi
        done <<< "$ALL_FILES"

        AGGREGATED_DATA=$(mktemp)
        if [ -s "$TARGETS_DATA" ]; then
          sort "$TARGETS_DATA" | awk -F'|' '
          {
            target = $1
            total_lines[target] += $2
            covered_lines[target] += $3
          }
          END {
            for (target in total_lines) {
              print target "|" total_lines[target] "|" covered_lines[target]
            }
          }' > "$AGGREGATED_DATA"
        fi

        target_counter=1
        total_coverage_sum=0
        target_count=0
        total_lines_sum=0

        if [ -s "$AGGREGATED_DATA" ]; then
          while IFS='|' read -r target_name total_lines covered_lines; do
            if [ -n "$target_name" ]; then
              [ $total_lines -gt 0 ] && target_coverage=$(echo "scale=6; $covered_lines * 100 / $total_lines" | bc) || target_coverage=0
              target_coverage_rounded=$(echo "$target_coverage" | awk '{print int($1 * 100 + 0.5) / 100}')
              echo "| $target_counter | $target_name | $total_lines | **${target_coverage_rounded}%** |" >> "$TABLE_BODY"
              echo "$target_coverage" >> "$COVERAGE_VALUES"
              total_lines_sum=$((total_lines_sum + total_lines))
              target_counter=$((target_counter + 1))
            fi
          done < <(sort "$AGGREGATED_DATA")
        else
          echo "| 1 | $PROJECT_NAME | 0 | **0%** |" >> "$TABLE_BODY"
        fi

        if [ -f "$COVERAGE_VALUES" ]; then
          target_count=$(wc -l < "$COVERAGE_VALUES")
          if [ $target_count -gt 0 ]; then
            total_coverage_sum=$(awk '{sum+=$1} END {print sum}' "$COVERAGE_VALUES")
            average_coverage=$(echo "scale=6; $total_coverage_sum / $target_count" | bc)
          else
            average_coverage=0
          fi
          rm -f "$COVERAGE_VALUES"
        else
          average_coverage=0
        fi

        average_coverage_rounded=$(echo "$average_coverage" | awk '{print int($1 * 100 + 0.5) / 100}')

        coverage_header="Coverage"
        if [ "$show_quality" = "true" ]; then
          coverage_int=$(echo "$average_coverage_rounded" | awk '{print int($1)}')
          [ "$coverage_int" -lt "$THRESHOLD" ] && coverage_header="‚ö†Ô∏è" || coverage_header="‚úÖ"
        fi

        cat <<EOF > ${{ env.COVERAGE_SUMMARY_FILE }}
        |   ‚Ññ  | Target | Lines | $coverage_header |
        |:----:|--------|------:|:---------:|
        EOF
        cat "$TABLE_BODY" >> ${{ env.COVERAGE_SUMMARY_FILE }}

        [ $target_count -gt 1 ] && echo "| | <p align=\"right\">**Total**</p> | $total_lines_sum | **${average_coverage_rounded}%** |" >> ${{ env.COVERAGE_SUMMARY_FILE }}

        rm -f "$TABLE_BODY"
        echo "coverage=$average_coverage_rounded" >> $GITHUB_OUTPUT
        echo "coverage-table<<EOF" >> $GITHUB_OUTPUT
        cat ${{ env.COVERAGE_SUMMARY_FILE }} >> $GITHUB_OUTPUT
        echo "EOF" >> $GITHUB_OUTPUT
        [ -n "$THRESHOLD" ] && echo "threshold=$THRESHOLD" >> $GITHUB_OUTPUT || echo "threshold=" >> $GITHUB_OUTPUT

        echo ""
        echo "üìä Coverage Summary:"
        if [ -s "$AGGREGATED_DATA" ]; then
          while IFS='|' read -r target_name total_lines covered_lines; do
            if [ -n "$target_name" ]; then
              [ $total_lines -gt 0 ] && target_coverage=$(echo "scale=6; $covered_lines * 100 / $total_lines" | bc) || target_coverage=0
              target_coverage_rounded=$(echo "$target_coverage" | awk '{print int($1 * 100 + 0.5) / 100}')
              echo "  ‚Ä¢ $target_name: ${target_coverage_rounded}%"
            fi
          done < <(sort "$AGGREGATED_DATA")
        fi
        echo "  Overall: ${average_coverage_rounded}%"
        [ -n "$THRESHOLD" ] && echo "  Threshold: ${THRESHOLD}%"
        echo ""

        rm -f "$TARGETS_DATA" "$AGGREGATED_DATA"

    - name: Comment on Pull Request
      if: github.event_name == 'pull_request' && inputs.post-comment
      uses: actions/github-script@v7
      with:
        script: |
          const fs = require('fs');

          // Read coverage output from file
          const coverageOutput = fs.readFileSync('${{ env.COVERAGE_SUMMARY_FILE }}', 'utf8');

          // Create unique identifier using GitHub's job context
          const workflowName = '${{ github.workflow }}';
          const jobName = '${{ github.job }}';
          const customJobName = '${{ inputs.job-name }}';
          const jobId = customJobName || `${workflowName}:${jobName}`;
          const commentMarker = `<!-- swift-coverage-id: ${jobId} -->`;

          // Build threshold details if threshold provided
          const thresholdStr = '${{ steps.extract.outputs.threshold }}';
          const threshold = thresholdStr ? parseInt(thresholdStr, 10) : null;
          let thresholdSection = '';
          if (threshold !== null && threshold !== undefined) {
            thresholdSection = `
          <details>
          <summary><b>Details</b></summary>

          ### Threshold - ${threshold}%
            - ‚ö†Ô∏è below
            - ‚úÖ meets

          </details>
          `;
          }

          const header = '${{ inputs.coverage-comment-header }}';
          const newComment = `
          ${header}

          ${coverageOutput}
          ${thresholdSection}
          _Generated by [Swift Coverage Action](https://github.com/Snapp-Mobile/swift-coverage-action)._
          ${commentMarker}
          `;

          // Fetch existing comments
          const comments = await github.rest.issues.listComments({
            owner: context.repo.owner,
            repo: context.repo.repo,
            issue_number: context.payload.pull_request.number,
          });

          // Identify and delete ONLY previous comments with the same job ID
          const botComments = comments.data.filter(comment =>
            comment.body.includes(commentMarker)
          );

          for (const botComment of botComments) {
            await github.rest.issues.deleteComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              comment_id: botComment.id,
            });
          }

          // Create a comment on the pull request
          await github.rest.issues.createComment({
            issue_number: context.payload.pull_request.number,
            owner: context.repo.owner,
            repo: context.repo.repo,
            body: newComment,
          });

          console.log(`‚úÖ Coverage comment posted successfully (ID: ${jobId})`);

    - name: Check Coverage Threshold
      if: inputs.fail-on-low-coverage && inputs.coverage-threshold != ''
      run: |
        COVERAGE=${{ steps.extract.outputs.coverage }}
        THRESHOLD="${{ inputs.coverage-threshold }}"

        echo "Coverage: ${COVERAGE}%"
        echo "Threshold: ${THRESHOLD}%"

        COVERAGE_INT=$(echo "$COVERAGE" | awk '{print int($1)}')

        if [ "$COVERAGE_INT" -lt "$THRESHOLD" ]; then
          echo "::error title=Coverage Below Threshold::Coverage ${COVERAGE}% is below the required threshold of ${THRESHOLD}%"
          exit 1
        else
          echo "‚úÖ Coverage ${COVERAGE}% meets threshold ${THRESHOLD}%"
        fi
