name: Swift Test Coverage
description: Automated code coverage reporting for Swift packages
author: oleksiikolomiiets

branding:
  icon: shield
  color: green

tags:
  - swift
  - coverage
  - testing
  - code-quality
  - ci-cd
  - spm

inputs:
  # Basic configuration
  macos-version:
    description: 'macOS runner version (e.g., "latest", "15", "14")'
    required: false
    default: 'latest'
  xcode-version:
    description: 'Xcode version to use (default: system default)'
    required: false
    default: ''
  source-path-override:
    description: 'Override source path pattern (default: {PROJECT}/Sources)'
    required: false
    default: ''
  project-name-override:
    description: 'Override project name (default: repository name)'
    required: false
    default: ''
  coverage-comment-header:
    description: 'Header for coverage comment'
    required: false
    default: '### üõ°Ô∏è Code Coverage Report'
  working-directory:
    description: 'Working directory for Swift commands (default: repository root)'
    required: false
    default: '.'
  skip-label:
    description: 'Label name to skip workflow execution (default: skip-coverage)'
    required: false
    default: 'skip-coverage'

  # Multi-job combined comments
  post-comment:
    description: 'Post coverage comment to PR (set to false when using combined comments)'
    required: false
    default: 'true'
  job-name:
    description: 'Name/description for this coverage job (used in combined reports)'
    required: false
    default: ''

  # Coverage threshold
  coverage-threshold:
    description: 'Coverage threshold percentage (if set, enables quality indicators and Details section)'
    required: false
    default: ''
  fail-on-low-coverage:
    description: 'Fail the job if coverage is below threshold'
    required: false
    default: 'false'

outputs:
  coverage-percentage:
    description: 'The calculated coverage percentage'
    value: ${{ steps.extract.outputs.coverage }}
  coverage-table:
    description: 'The coverage table in markdown format'
    value: ${{ steps.extract.outputs.coverage-table }}
  job-name:
    description: 'The job name for this coverage run'
    value: ${{ inputs.job-name }}

runs:
  using: composite
  steps:
    - name: Check for skip label
      id: skip-check
      shell: bash
      run: |
        if [ "${{ github.event_name }}" = "pull_request" ]; then
          LABELS='${{ toJSON(github.event.pull_request.labels.*.name) }}'
          if echo "$LABELS" | grep -q '"${{ inputs.skip-label }}"'; then
            echo "‚è≠Ô∏è  Skip label '${{ inputs.skip-label }}' found - skipping coverage"
            echo "skip=true" >> $GITHUB_OUTPUT
          else
            echo "skip=false" >> $GITHUB_OUTPUT
          fi
        else
          echo "skip=false" >> $GITHUB_OUTPUT
        fi

    - name: Checkout code
      if: steps.skip-check.outputs.skip != 'true'
      uses: actions/checkout@v4

    - name: List Xcode installations
      if: steps.skip-check.outputs.skip != 'true'
      shell: bash
      run: sudo ls -1 /Applications | grep "Xcode" || echo "No Xcode installations found"

    - name: Validate Xcode version
      if: steps.skip-check.outputs.skip != 'true' && inputs.xcode-version != ''
      shell: bash
      run: |
        REQUESTED_XCODE="Xcode_${{ inputs.xcode-version }}.app"
        if [ ! -d "/Applications/$REQUESTED_XCODE" ]; then
          echo "‚ùå Error: Xcode version ${{ inputs.xcode-version }} is not installed"
          echo ""
          echo "Available Xcode versions:"
          sudo ls -1 /Applications | grep "Xcode" | sed 's/Xcode_//g' | sed 's/.app//g' | sed 's/^/  - /'
          echo ""
          echo "Please update your workflow to use one of the available versions."
          exit 1
        fi
        echo "‚úÖ Xcode ${{ inputs.xcode-version }} is available"

    - name: Select Xcode version
      if: steps.skip-check.outputs.skip != 'true' && inputs.xcode-version != ''
      shell: bash
      run: |
        XCODE_PATH="/Applications/Xcode_${{ inputs.xcode-version }}.app/Contents/Developer"
        sudo xcode-select -s "$XCODE_PATH"

    - name: Verify Swift Version
      if: steps.skip-check.outputs.skip != 'true'
      shell: bash
      run: swift --version

    - name: Detect Platforms from Package.swift
      if: steps.skip-check.outputs.skip != 'true'
      id: detect-platforms
      shell: bash
      working-directory: ${{ inputs.working-directory }}
      run: |
        echo "üîç Detecting platforms from Package.swift..."
        echo ""

        # Check if Package.swift exists
        if [ ! -f "Package.swift" ]; then
          echo "‚ö†Ô∏è  Package.swift not found in working directory"
          echo "Defaulting to macOS platform"
          PLATFORMS_TO_TEST="macos"
        else
          # Parse Package.swift to detect platforms
          echo "üì¶ Parsing Package.swift..."

          set +e
          PACKAGE_JSON=$(swift package dump-package 2>&1)
          DUMP_EXIT_CODE=$?
          set -e

          if [ $DUMP_EXIT_CODE -ne 0 ]; then
            echo "‚ö†Ô∏è  Failed to parse Package.swift:"
            echo "$PACKAGE_JSON"
            echo ""
            echo "Defaulting to macOS platform"
            PLATFORMS_TO_TEST="macos"
          else
            # Extract platform names (lowercase)
            DETECTED_PLATFORMS=$(echo "$PACKAGE_JSON" | jq -r '.platforms[]?.platformName // empty' | tr '\n' ',' | sed 's/,$//')

            if [ -z "$DETECTED_PLATFORMS" ]; then
              # No platforms specified in Package.swift - default to macOS
              PLATFORMS_TO_TEST="macos"
              echo "‚ÑπÔ∏è  No platforms specified in Package.swift"
              echo "Defaulting to macOS platform"
            else
              PLATFORMS_TO_TEST="$DETECTED_PLATFORMS"
              echo "‚úÖ Detected platforms: $PLATFORMS_TO_TEST"
            fi
          fi
        fi

        echo ""
        echo "platforms=$PLATFORMS_TO_TEST" >> $GITHUB_OUTPUT

        # Log for visibility
        echo "üìã Platform detection complete"
        echo "   Platforms: $PLATFORMS_TO_TEST"
        echo ""

    - name: Run Swift Tests with Coverage
      if: steps.skip-check.outputs.skip != 'true'
      shell: bash
      working-directory: ${{ inputs.working-directory }}
      run: |
        PLATFORMS="${{ steps.detect-platforms.outputs.platforms }}"

        echo "üß™ Running tests for platforms: $PLATFORMS"
        echo ""

        # Get project name for scheme (used by xcodebuild)
        PROJECT_NAME="${{ inputs.project-name-override }}"
        if [ -z "$PROJECT_NAME" ]; then
          PROJECT_NAME="${{ github.event.repository.name }}"
        fi

        # Create temp file to store coverage paths from all platforms
        COVERAGE_PATHS_FILE=$(mktemp)
        FAILED_PLATFORMS=""

        # Split platforms by comma and loop
        IFS=',' read -ra PLATFORM_ARRAY <<< "$PLATFORMS"

        for platform in "${PLATFORM_ARRAY[@]}"; do
          # Trim whitespace
          platform=$(echo "$platform" | xargs)

          echo "========================================"
          echo "Testing platform: $platform"
          echo "========================================"
          echo ""

          case "$platform" in
            macos)
              echo "üñ•Ô∏è  macOS platform - using swift test"
              echo ""

              set +e
              swift test --enable-swift-testing --enable-code-coverage
              TEST_EXIT_CODE=$?
              set -e

              if [ $TEST_EXIT_CODE -eq 0 ]; then
                CODECOV_PATH=$(swift test --enable-swift-testing --enable-code-coverage --show-codecov-path)
                echo "macos|spm|$CODECOV_PATH" >> "$COVERAGE_PATHS_FILE"
                echo "‚úÖ macOS tests completed successfully"
                echo "üìä Coverage: $CODECOV_PATH"
              else
                echo "‚ùå Error: macOS tests failed with exit code $TEST_EXIT_CODE"
                FAILED_PLATFORMS="$FAILED_PLATFORMS macos"
              fi
              ;;

            ios)
              echo "üì± iOS platform - using xcodebuild with simulator"
              echo ""

              # Get the latest iOS runtime
              echo "üîç Finding iOS runtime..."
              RUNTIME=$(xcrun simctl list runtimes | grep "iOS" | grep -v "unavailable" | tail -1 | grep -oE "com\.apple\.CoreSimulator\.SimRuntime\.iOS-[0-9-]+")

              if [ -z "$RUNTIME" ]; then
                echo "‚ùå Error: No iOS runtime available"
                xcrun simctl list runtimes
                FAILED_PLATFORMS="$FAILED_PLATFORMS ios"
                continue
              fi

              echo "‚úÖ Using runtime: $RUNTIME"

              # Create iOS simulator
              echo "üì≤ Creating iOS Simulator (iPhone 15)..."
              set +e
              SIMULATOR_ID=$(xcrun simctl create swift-coverage-ios com.apple.CoreSimulator.SimDeviceType.iPhone-15 "$RUNTIME" 2>&1 | tail -1)
              CREATE_EXIT_CODE=$?
              set -e

              if [ $CREATE_EXIT_CODE -ne 0 ]; then
                echo "‚ùå Error: Failed to create iOS simulator"
                FAILED_PLATFORMS="$FAILED_PLATFORMS ios"
                continue
              fi

              echo "‚úÖ Created simulator: $SIMULATOR_ID"

              # Boot simulator
              echo "‚è≥ Booting simulator..."
              set +e
              xcrun simctl boot "$SIMULATOR_ID"
              BOOT_EXIT_CODE=$?
              set -e

              if [ $BOOT_EXIT_CODE -ne 0 ]; then
                echo "‚ùå Error: Failed to boot simulator"
                xcrun simctl delete "$SIMULATOR_ID" || true
                FAILED_PLATFORMS="$FAILED_PLATFORMS ios"
                continue
              fi

              echo "‚úÖ Simulator booted, waiting for ready state..."
              sleep 5

              # Run tests
              echo "üß™ Running tests on iOS Simulator..."
              set +e
              xcodebuild test \
                -scheme "$PROJECT_NAME" \
                -destination "id=$SIMULATOR_ID" \
                -derivedDataPath .build/ios \
                -enableCodeCoverage YES
              TEST_EXIT_CODE=$?
              set -e

              # Cleanup simulator
              echo "üßπ Cleaning up simulator..."
              xcrun simctl shutdown "$SIMULATOR_ID" || true
              xcrun simctl delete "$SIMULATOR_ID" || true

              if [ $TEST_EXIT_CODE -eq 0 ]; then
                XCRESULT=$(find .build/ios -name "*.xcresult" -type d | head -1)
                if [ -n "$XCRESULT" ]; then
                  echo "ios|xcresult|$XCRESULT" >> "$COVERAGE_PATHS_FILE"
                  echo "‚úÖ iOS tests completed successfully"
                  echo "üìä Coverage: $XCRESULT"
                else
                  echo "‚ö†Ô∏è  Warning: No coverage data found"
                fi
              else
                echo "‚ùå Error: iOS tests failed with exit code $TEST_EXIT_CODE"
                FAILED_PLATFORMS="$FAILED_PLATFORMS ios"
              fi
              ;;

            tvos|watchos|visionos)
              echo "‚è≠Ô∏è  Skipping $platform platform"
              echo "   Only iOS and macOS platforms are currently supported for testing"
              echo "   Detected platform will be ignored"
              ;;

            *)
              echo "‚ö†Ô∏è  Warning: Unsupported platform: $platform"
              ;;
          esac

          echo ""
        done

        # Save coverage paths file for processing
        echo "COVERAGE_PATHS_FILE=$COVERAGE_PATHS_FILE" >> $GITHUB_ENV

        # Report failures
        if [ -n "$FAILED_PLATFORMS" ]; then
          echo "‚ö†Ô∏è  Some platforms failed:$FAILED_PLATFORMS"
          echo "FAILED_PLATFORMS=$FAILED_PLATFORMS" >> $GITHUB_ENV
        fi

    - name: Process Coverage Data
      if: steps.skip-check.outputs.skip != 'true'
      id: extract
      shell: bash
      working-directory: ${{ inputs.working-directory }}
      run: |
        COVERAGE_PATHS_FILE="${{ env.COVERAGE_PATHS_FILE }}"

        # Merge all coverage data from different platforms into single SPM format
        MERGED_COVERAGE=$(mktemp)
        echo '{"data":[{"files":[]}]}' > "$MERGED_COVERAGE"

        echo "üìä Processing coverage data from all platforms..."
        echo ""

        # Loop through each platform's coverage file
        while IFS='|' read -r platform coverage_type coverage_path; do
          echo "Processing $platform coverage ($coverage_type)..."

          if [ "$coverage_type" = "xcresult" ]; then
            # Convert xcresult to SPM format
            COVERAGE_JSON=$(mktemp)
            xcrun xccov view --report --json "$coverage_path" > "$COVERAGE_JSON"

            # Transform xccov JSON to SPM format
            TRANSFORMED_JSON=$(mktemp)
            jq '{
              data: [{
                files: [
                  .targets[].files[] | {
                    filename: .path,
                    summary: {
                      lines: {
                        count: .executableLines,
                        covered: .coveredLines
                      }
                    }
                  }
                ]
              }]
            }' "$COVERAGE_JSON" > "$TRANSFORMED_JSON"

            # Merge into combined coverage
            jq -s '{data:[{files: (.[0].data[0].files + .[1].data[0].files)}]}' \
              "$MERGED_COVERAGE" "$TRANSFORMED_JSON" > "${MERGED_COVERAGE}.tmp"
            mv "${MERGED_COVERAGE}.tmp" "$MERGED_COVERAGE"

            rm -f "$COVERAGE_JSON" "$TRANSFORMED_JSON"

          elif [ "$coverage_type" = "spm" ]; then
            # Already in SPM format, just merge
            jq -s '{data:[{files: (.[0].data[0].files + .[1].data[0].files)}]}' \
              "$MERGED_COVERAGE" "$coverage_path" > "${MERGED_COVERAGE}.tmp"
            mv "${MERGED_COVERAGE}.tmp" "$MERGED_COVERAGE"
          fi

          echo "‚úÖ $platform coverage processed"
        done < "$COVERAGE_PATHS_FILE"

        # Use merged coverage for final processing
        CODECOV_PATH="$MERGED_COVERAGE"

        echo ""
        echo "‚úÖ All coverage data merged"
        echo ""

        # Set project name and source path
        PROJECT_NAME="${{ inputs.project-name-override }}"
        if [ -z "$PROJECT_NAME" ]; then
          PROJECT_NAME="${{ github.event.repository.name }}"
        fi

        SOURCE_PATH="${{ inputs.source-path-override }}"
        if [ -z "$SOURCE_PATH" ]; then
          SOURCE_PATH="${PROJECT_NAME}/Sources"
        fi

        # Check if there are any actual source files to report on
        SOURCE_FILE_COUNT=$(jq -r '.data[0].files[] | select(.filename | test("/\\.build/") | not) | select(.filename | test("\\.swift$")) | select(.filename | test("/(Tests?|test)/") | not) | .filename' "$CODECOV_PATH" | wc -l)

        if [ "$SOURCE_FILE_COUNT" -eq 0 ]; then
          # Create a placeholder entry when no source files exist
          ALL_FILES="$PROJECT_NAME|0|0"
        else
          # Extract all Swift files excluding build artifacts
          ALL_FILES=$(jq -r '.data[0].files[] | select(.filename | test("/\\.build/") | not) | select(.filename | test("\\.swift$")) | select(.filename | test("/(Tests?|test)/") | not) | "\(.filename)|\(.summary.lines.count)|\(.summary.lines.covered)"' "$CODECOV_PATH")
        fi

        # Initialize - check if threshold is set
        THRESHOLD="${{ inputs.coverage-threshold }}"
        if [ -n "$THRESHOLD" ]; then
          show_quality="true"
        else
          show_quality="false"
        fi

        # Create temporary files for target data
        TARGETS_DATA=$(mktemp)
        TABLE_BODY=$(mktemp)
        COVERAGE_SUMMARY_FILE="${{ github.workspace }}/coverage_summary.txt"

        # Parse files and group by target
        while IFS='|' read -r filename total_lines covered_lines; do
          if [ -n "$filename" ]; then
            # Extract target name from file path patterns:
            # Pattern 1: /path/to/TargetName/Sources/...
            # Pattern 2: /path/to/Sources/TargetName/...
            # Pattern 3: /path/to/TargetName/...
            target_name=""

            if echo "$filename" | grep -q '/Sources/[^/]*/'; then
              # Pattern: .../Sources/TargetName/...
              target_name=$(echo "$filename" | sed -E 's|.*/Sources/([^/]+)/.*|\1|')
            elif echo "$filename" | grep -q '/Sources/[^/]*\.swift$'; then
              # Pattern: .../Sources/file.swift (direct in Sources)
              target_name=$(echo "$filename" | sed -E 's|.*/Sources/([^/]*)\.swift$|\1|')
            else
              target_name="$PROJECT_NAME"
            fi

            # Skip if target name looks like a test
            if echo "$target_name" | grep -qi test; then
              continue
            fi

            # Write target data to temp file
            echo "$target_name|$total_lines|$covered_lines" >> "$TARGETS_DATA"
          fi
        done <<< "$ALL_FILES"

        # Aggregate data by target
        AGGREGATED_DATA=$(mktemp)
        if [ -s "$TARGETS_DATA" ]; then
          sort "$TARGETS_DATA" | awk -F'|' '
          {
            target = $1
            total_lines[target] += $2
            covered_lines[target] += $3
          }
          END {
            for (target in total_lines) {
              print target "|" total_lines[target] "|" covered_lines[target]
            }
          }' > "$AGGREGATED_DATA"
        fi

        # Generate table rows for each target
        target_counter=1
        total_coverage_sum=0
        target_count=0
        total_lines_sum=0

        if [ -s "$AGGREGATED_DATA" ]; then
          # Process each target and add to table
          while IFS='|' read -r target_name total_lines covered_lines; do
            if [ -n "$target_name" ]; then
              if [ $total_lines -gt 0 ]; then
                target_coverage=$(echo "scale=6; $covered_lines * 100 / $total_lines" | bc)
              else
                target_coverage=0
              fi

              target_coverage_rounded=$(echo "$target_coverage" | awk '{print int($1 * 100 + 0.5) / 100}')

              echo "| $target_counter | $target_name | $total_lines | **${target_coverage_rounded}%** |" >> "$TABLE_BODY"

              # For overall average calculation
              echo "$target_coverage" >> /tmp/coverage_values.txt
              total_lines_sum=$((total_lines_sum + total_lines))
              target_counter=$((target_counter + 1))

            fi
          done < <(sort "$AGGREGATED_DATA")
        else
          # Fallback: add a single entry with project name
          echo "| 1 | $PROJECT_NAME | 0 | **0%** |" >> "$TABLE_BODY"
        fi

        # Calculate overall average coverage
        if [ -f /tmp/coverage_values.txt ]; then
          target_count=$(wc -l < /tmp/coverage_values.txt)
          if [ $target_count -gt 0 ]; then
            total_coverage_sum=$(awk '{sum+=$1} END {print sum}' /tmp/coverage_values.txt)
            average_coverage=$(echo "scale=6; $total_coverage_sum / $target_count" | bc)
          else
            average_coverage=0
          fi
          rm -f /tmp/coverage_values.txt
        else
          average_coverage=0
        fi

        average_coverage_rounded=$(echo "$average_coverage" | awk '{print int($1 * 100 + 0.5) / 100}')

        # Determine header icon based on average coverage
        coverage_header="Coverage"
        if [ "$show_quality" = "true" ]; then
          coverage_int=$(echo "$average_coverage_rounded" | awk '{print int($1)}')
          if [ "$coverage_int" -lt "$THRESHOLD" ]; then
            coverage_header="‚ö†Ô∏è"
          else
            coverage_header="‚úÖ"
          fi
        fi

        # Write final table with header + body
        cat <<EOF > "$COVERAGE_SUMMARY_FILE"
        |   ‚Ññ  | Target | Lines | $coverage_header |
        |:----:|--------|------:|:---------:|
        EOF
        cat "$TABLE_BODY" >> "$COVERAGE_SUMMARY_FILE"

        # Add average/combined coverage row if multiple targets
        if [ $target_count -gt 1 ]; then
          echo "| | <p align=\"right\">**Total**</p> | $total_lines_sum | **${average_coverage_rounded}%** |" >> "$COVERAGE_SUMMARY_FILE"
        fi

        # Clean up temp files
        rm -f "$TABLE_BODY"

        # Output for next steps
        echo "coverage=$average_coverage_rounded" >> $GITHUB_OUTPUT

        # Output table for combined comments
        echo "coverage-table<<EOF" >> $GITHUB_OUTPUT
        cat "$COVERAGE_SUMMARY_FILE" >> $GITHUB_OUTPUT
        echo "EOF" >> $GITHUB_OUTPUT

        # Output threshold for comment footer (if set)
        if [ -n "$THRESHOLD" ]; then
          echo "threshold=$THRESHOLD" >> $GITHUB_OUTPUT
        else
          echo "threshold=" >> $GITHUB_OUTPUT
        fi

        # Echo coverage summary to logs (visible for all workflows: PR, direct push, etc.)
        echo ""
        echo "üìä Coverage Summary:"
        if [ -s "$AGGREGATED_DATA" ]; then
          while IFS='|' read -r target_name total_lines covered_lines; do
            if [ -n "$target_name" ]; then
              if [ $total_lines -gt 0 ]; then
                target_coverage=$(echo "scale=6; $covered_lines * 100 / $total_lines" | bc)
              else
                target_coverage=0
              fi
              target_coverage_rounded=$(echo "$target_coverage" | awk '{print int($1 * 100 + 0.5) / 100}')
              echo "  ‚Ä¢ $target_name: ${target_coverage_rounded}%"
            fi
          done < <(sort "$AGGREGATED_DATA")
        fi
        echo "  Overall: ${average_coverage_rounded}%"
        if [ -n "$THRESHOLD" ]; then
          echo "  Threshold: ${THRESHOLD}%"
        fi
        echo ""

        # Clean up temp files
        rm -f "$TARGETS_DATA" "$AGGREGATED_DATA"

    - name: Comment on Pull Request
      if: steps.skip-check.outputs.skip != 'true' && github.event_name == 'pull_request' && inputs.post-comment == 'true'
      uses: actions/github-script@v7
      with:
        script: |
          const fs = require('fs');

          // Read coverage output from file
          const coverageOutput = fs.readFileSync('${{ github.workspace }}/coverage_summary.txt', 'utf8');

          // Create unique identifier using GitHub's job context
          const workflowName = '${{ github.workflow }}';
          const jobName = '${{ github.job }}';
          const customJobName = '${{ inputs.job-name }}';
          const jobId = customJobName || `${workflowName}:${jobName}`;
          const commentMarker = `<!-- swift-coverage-id: ${jobId} -->`;

          // Build threshold details if threshold provided
          const thresholdStr = '${{ steps.extract.outputs.threshold }}';
          const threshold = thresholdStr ? parseInt(thresholdStr, 10) : null;
          let thresholdSection = '';
          if (threshold !== null && threshold !== undefined) {
            thresholdSection = `
          <details>
          <summary><b>Details</b></summary>

          ### Threshold - ${threshold}%
            - ‚ö†Ô∏è below
            - ‚úÖ meets

          </details>
          `;
          }

          const header = '${{ inputs.coverage-comment-header }}';
          const newComment = `
          ${header}

          ${coverageOutput}
          ${thresholdSection}
          _Generated by [Swift Coverage Action](https://github.com/Snapp-Mobile/swift-coverage-action)._
          ${commentMarker}
          `;

          // Fetch existing comments
          const comments = await github.rest.issues.listComments({
            owner: context.repo.owner,
            repo: context.repo.repo,
            issue_number: context.payload.pull_request.number,
          });

          // Identify and delete ONLY previous comments with the same job ID
          const botComments = comments.data.filter(comment =>
            comment.body.includes(commentMarker)
          );

          for (const botComment of botComments) {
            await github.rest.issues.deleteComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              comment_id: botComment.id,
            });
          }

          // Create a comment on the pull request
          await github.rest.issues.createComment({
            issue_number: context.payload.pull_request.number,
            owner: context.repo.owner,
            repo: context.repo.repo,
            body: newComment,
          });

          console.log(`‚úÖ Coverage comment posted successfully (ID: ${jobId})`);

    - name: Check Coverage Threshold
      if: steps.skip-check.outputs.skip != 'true' && inputs.fail-on-low-coverage == 'true' && inputs.coverage-threshold != ''
      shell: bash
      run: |
        COVERAGE=${{ steps.extract.outputs.coverage }}
        THRESHOLD="${{ inputs.coverage-threshold }}"

        echo "Coverage: ${COVERAGE}%"
        echo "Threshold: ${THRESHOLD}%"

        COVERAGE_INT=$(echo "$COVERAGE" | awk '{print int($1)}')

        if [ "$COVERAGE_INT" -lt "$THRESHOLD" ]; then
          echo "::error title=Coverage Below Threshold::Coverage ${COVERAGE}% is below the required threshold of ${THRESHOLD}%"
          exit 1
        else
          echo "‚úÖ Coverage ${COVERAGE}% meets threshold ${THRESHOLD}%"
        fi
